
<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="icon" type="image/png" href="/img/sand2.png">
  <link rel="shortcut icon" type="image/x-icon" href="/img/sand2.png">
  <meta property="og:image" content="https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png">
  
  <link rel="stylesheet" href="/css/style.css?v=1.3"> 
  <link href="//vjs.zencdn.net/6.7/video-js.min.css" rel="stylesheet">
  <script src="//vjs.zencdn.net/6.7/video.min.js"></script>
  
  <title>Smart【智能】 Contract【合约】 | 小沙丘的网络漫游记</title>
 <meta name="description" content="" >

 <!-- 百度统计 -->
 <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?eafa0040e1ab3bed28ce82ef03de6e01";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css"></head>
<body>
  
  <script>
      if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
        document.body.classList.add('mobile');            
      } else{
        document.body.classList.add('pc');
        document.getElementsByTagName("html")[0].style.fontSize="62.5%";
      }
      var u = navigator.userAgent;
var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if(isiOS){
  document.body.classList.add('ios');
  document.getElementsByTagName("html")[0].style.fontSize="65%";
           
}
    </script>

  <div class="container">
<!-- 用于文章页面的顶部，提供返回主页和主题页的按键 -->
<!-- 头部开始 -->

<div id="header">
    <p>小沙丘的网络漫游记
      <span> » 
        <a href="/home/">首页</a>
      </span>
      
      <span> » 
          <a href="/tags/EOS/">
            EOS
          </a>
      </span>
      
    </p>
</div>

<!-- 头部结束 -->



<!-- 分类组件，放置于文章页面的顶部，提供上(或下)一篇导航按键。 -->
<div class="asset-nav">
    <div class="entry-categories">
      <p>主题：
        <span> 
            <a href="/tags/EOS/">
              EOS
            </a>
        </span>
      </p>
    </div>
    <div class="entry-location-mobile">
        <span>
            
            <a href="/2018/05/21/online-eos-10/">
            &#8676;
            </a>
        </span>
        <span>
            
            <a href="/2018/05/21/online-eos-12/">
              &#8677;
            </a>
        </span>
    </div>
    <div class="entry-location">
        <P>上一篇：
                <a href="/2018/05/21/online-eos-10/">
                    Persistence【存储】 API
                </a>
        </P>
        <P>下一篇：

                <a href="/2018/05/21/online-eos-12/">
                    Getting Started【启动】 With Contracts【合约】 | 教程
                </a>
        </P>
    </div>
</div>

<div class="post">
<div class="title-post">
<h1>Smart【智能】 Contract【合约】</h1>
<div class="post-meta">
  <p>作者： Lian</p>
  <p>日期：
    2018年05月21日 20:05
  </p>
</div>
</div>



  
  <div class="page">
      <p>Introduction to EOSIO Smart Contracts<br>A real-world contract, simply stated, is an agreement governing outcomes for actions, given a set of inputs. A contract can range from formal legal contracts (e.g., a financial transaction) to something as simple as the “rules” of a game. Typical actions can be things such as fund transfers (in the case of a financial contract) or game moves (in the case of a game contract).</p>
<p>An EOSIO Smart Contract is software registered on the blockchain and executed on EOSIO nodes, that implements the semantics of a “contract” whose ledger of action requests are being stored on the blockchain. The Smart Contract defines the interface (actions, parameters, data structures) and the code that implements the interface. The code is compiled into a canonical bytecode format that nodes can retrieve and execute. The blockchain stores the transactions (e.g., legal transfers, game moves) of the contract. Each Smart Contract must be accompanied by a Ricardian Contract that defines the legally binding terms and conditions of the contract.</p>
<p>Required Background Knowledge<br>C / C++ Experience<br>EOSIO based blockchains execute user-generated applications and code using WebAssembly (WASM). WASM is an emerging web standard with widespread support of Google, Microsoft, Apple, and others. The most mature toolchain for building applications that compile to WASM is clang/llvm with their C/C++ compiler. For best compatibility, it is recommended that you use the EOSIO toolchain.</p>
<p>Other toolchains in development by 3rd parties include: Rust, Python, and Solidity. While these other languages might appear simpler, their performance will likely impact the scale of application you can build. We expect that C++ will be the best language for developing high-performance and secure smart contracts, and plan to use C++ for the foreseeable future.</p>
<p>Linux / Mac OS Experience<br>The EOSIO software supports the following environments:</p>
<p>Amazon 2017.09 and higher<br>Centos 7<br>Fedora 25 and higher (Fedora 27 recommended)<br>Mint 18<br>Ubuntu 16.04 (Ubuntu 16.10 recommended)<br>MacOS Darwin 10.12 and higher (MacOS 10.13.x recommended)<br>Command Line Knowledge<br>There are a variety of tools provided along with EOSIO that require you to have basic command line knowledge in order to interact with them.</p>
<p>Basics of EOSIO Smart Contracts<br>Overview<br>An EOSIO Smart Contract consists of a set of action and type definitions. Action definitions specify and implement the behaviors of the contract. The type definitions specify the required content and structures. EOSIO actions operate primarily in a message-based communication architecture. A client invokes actions by sending (pushing) messages to nodeos. This can be done using the cleos command. It can also be done using one of the EOSIO send methods (e.g., eosio::action::send). nodeos dispatches action requests to the WASM code that implements a contract. That code runs in its entirety, then processing continues to the next action.</p>
<p>Action vs Transaction<br>An action represents a single operation, whereas a transaction is a collection of one or more actions. A contract and an account communicate in the form of actions. Actions can be sent individually, or in combined form if they are intended to be executed as a whole.</p>
<p>Transaction with one action.</p>
<p>{<br>  “expiration”: “2018-04-01T15:20:44”,<br>  “region”: 0,<br>  “ref_block_num”: 42580,<br>  “ref_block_prefix”: 3987474256,<br>  “net_usage_words”: 21,<br>  “kcpu_usage”: 1000,<br>  “delay_sec”: 0,<br>  “context_free_actions”: [],<br>  “actions”: [{<br>      “account”: “eosio.token”,<br>      “name”: “issue”,<br>      “authorization”: [{<br>          “actor”: “eosio”,<br>          “permission”: “active”<br>        }<br>      ],<br>      “data”: “00000000007015d640420f000000000004454f5300000000046d656d6f”<br>    }<br>  ],<br>  “signatures”: [<br>    “”<br>  ],<br>  “context_free_data”: []<br>}<br>Transaction with multiple actions, these actions must all succeed or the transaction will fail.</p>
<p>{<br>  “expiration”: “…”,<br>  “region”: 0,<br>  “ref_block_num”: …,<br>  “ref_block_prefix”: …,<br>  “net_usage_words”: ..,<br>  “kcpu_usage”: ..,<br>  “delay_sec”: 0,<br>  “context_free_actions”: [],<br>  “actions”: [{<br>      “account”: “…”,<br>      “name”: “…”,<br>      “authorization”: [{<br>          “actor”: “…”,<br>          “permission”: “…”<br>        }<br>      ],<br>      “data”: “…”<br>    }, {<br>      “account”: “…”,<br>      “name”: “…”,<br>      “authorization”: [{<br>          “actor”: “…”,<br>          “permission”: “…”<br>        }<br>      ],<br>      “data”: “…”<br>    }<br>  ],<br>  “signatures”: [<br>    “”<br>  ],<br>  “context_free_data”: []<br>}<br>Transaction Confirmation<br>On completion of the transaction, a transaction receipt is generated. Receiving a transaction hash does not mean that the transaction has been confirmed, it only means that the node accepted it without error, which also means that there is a high probability other producers will accept it.</p>
<p>By means of confirmation, you should see the transaction in the transaction history with the block number of which it is included.</p>
<p>Action Name Restrictions<br>Action types are actually base32 encoded 64-bit integers. This means they are limited to the characters a-z, 1-5, and ‘.’ for the first 12 characters. If there is a 13th character then it is restricted to the first 16 characters (‘.’ and a-p).</p>
<p>Action Handlers and Action “Apply” Context<br>Smart contracts provide action handlers to do the work of requested actions. (More on this below) Each time an action runs, i.e., the action is “applied” by running the apply method in the contract implementation, EOSIO creates a new action “apply” context within which the action runs. The diagram below illustrates key elements of the action “apply” context.</p>
<p>Action “Apply” Context</p>
<p>From a global view of an EOSIO blockchain, every node in the EOSIO network gets a copy of and runs every action in every contract. Some of the nodes are doing the actual work of the contract, while others are processing in order to prove the validity of the transaction blocks. It is, therefore, important that contracts be able to determine “who they are”, or basically, under which context are they running. Context identification information is provided in the action context, as illustrated in the above diagram by receiver, code, action. receiver is the account that is currently processing the action. code is the account that authorized the contract. action is the ID of the currently running action.</p>
<p>As discussed above, actions operate within transactions; if a transaction fails, the results of all actions in the transaction must be rolled back. A key part of the action context is the Current Transaction Data. This contains a transaction header, an ordered vector of all of the original actions in the transaction, a vector of the context free actions in the transaction, a prunable set of context free data (provided as a vector of blobs) defined by the code that implements the contract, and a full index to the vector of blobs.</p>
<p>Before processing an action, EOSIO sets up a clean working memory for the action. This is where the working variables for the action are held. An action’s working memory is available only to that action, even for actions in the same transaction. Variables that might have been set when another action executed are not available within another action’s context. The only way to pass state among actions is to persist it to and retrieve it from the EOSIO database. See Persistence API for details on how to use the EOSIO persistence services.</p>
<p>An action can have many side effects. Among these are:</p>
<p>Change state persisted in the EOSIO persistent storage<br>Notify the recipient of the current transaction<br>Send inline action requests to a new receiver<br>Generate new (deferred) transactions<br>Cancel existing (in-flight) deferred transactions (i.e., cancel already-submitted deferred transaction requests)<br>Communication Model and Execution Flow<br>EOSIO Smart Contracts can communicate with each other, e.g., to have another contract perform some operation pertinent to the completion of the current transaction, or to trigger a future transaction outside of the scope of the current transaction.</p>
<p>EOSIO supports two basic communication models, inline and deferred. An operation to perform within the current transaction is an example of an inline action, while a triggered future transaction is an example of a deferred action.</p>
<p>Communication among contracts should be considered as occurring asynchronously. The asynchronous communication model can result in spam, which the resource limiting algorithm will resolve.</p>
<p>Inline Communication<br>Inline communication takes the form of requesting other actions that need to be executed as part of the calling action. Inline actions operate with the same scopes and authorities of the original transaction, and are guaranteed to execute with the current transaction. These can effectively be thought of as nested transactions within the calling transaction. If any part of the transaction fails, the inline actions will unwind with the rest of the transaction. Calling the inline action generates no notification outside the scope of the transaction, regardless of success or failure.</p>
<p>Deferred Communication<br>Deferred communication conceptually takes the form of action notifications sent to a peer transaction. Deferred actions get scheduled to run, at best, at a later time, at the producer’s discretion. There is no guarantee that a deferred action will be executed.</p>
<p>As already mentioned, deferred communication will get scheduled later at the producer’s discretion. From the perspective of the originating transaction, i.e., the transaction that creates the deferred transaction, it can only determine whether the create request was submitted successfully or whether it failed (if it fails, it will fail immediately). Deferred transactions carry the authority of the contract that sends them. A transaction can cancel a deferred transaction.</p>
<p>Example Transaction Flow<br>The following diagram illustrates a multi-action transaction that has multiple levels of inline actions. Imagine a scenario where an Employer runs its payroll, transferring payment into its Employees’ accounts. The Employee accounts are managed by a Bank. The Bank offers notification to its customers (Employees) so that the customer can take advantage of Bank-offered services such as automatic transfer between checking and savings accounts.</p>
<p>Example transaction flow</p>
<p>In this example, the original transaction contains two actions on an employer contract: employer::runpayroll and employer::dootherstuff. The more interesting of the two actions is runpayroll. Here is what it does. Indentation corresponds with the nesting of the inline actions called.</p>
<p>runpayroll does an inline eosio::token::transfer action from the Employer account to the Bank account. This example chooses to embed in the “memo” field of the transfer the info needed by Bank to make sure the right Employee gets paid. This is needed because the accounts involved in the eosio::token::transfer are Employer and Bank.<br>eosio::token::transfer action does the token transfer state changes,<br>then notifies the Employer (which does nothing),<br>then notifies the Bank.<br>The Bank has a contract that listens for the eosio::token::transfer notification. On receipt, the parameters in the “memo” of the original action are used for some application-specific work to transfer money into the Employee’s account.<br>The Bank’s action notifies the Employee account of the deposit.<br>The Employee has a contract that listens for the eosio::token::transfer notification. On receipt, the parameters are used to determine that the transfer is for itself, the Employee’s contract sends an inline action bank::doacctpolicy.<br>bank::doacctpolicy performs some action for its customers based on customer-configured policy, e.g., to transfer funds between the Employee’s checking and savings accounts it has with Bank.<br>dootherstuff does some other action, illustrating that a transaction can have multiple actions.<br>The following diagram portrays the transaction trace tree equivalent of the example above.</p>
<p>Example transaction trace tree</p>
<p>Example Deferred Transaction Flow<br>The above scenario could also be done using a deferred transaction. The following diagram shows the deferred transaction scenario.</p>
<p>Example deferred transaction flow</p>
<p>Using a deferred transaction has some pretty significant differences. First, it can be seen that the Employee submits a deferred action rather than an inline action. Second, instead of the action being delivered for processing, it is queued for possible future processing. This is a very important characteristic of deferred transactions to be aware of! Third, the action, if/when invoked, occurs in a transaction independent of the original transaction that issued the deferred request. This last point highlights one motivation for using a deferred transaction. In the case of the example used here, an Employee likely does not want their receipt of a paycheck from their Employer being dependent on whether their Bank is able to successfully transfer funds from the Employee’s checking to savings. If the deferred transaction never gets processed, the Employee can manually make the transfer, or the Bank can have an out-of-band process that periodically processes such transactions.</p>
<p>Smart Contract Files<br>The eosiocpp tool simplifies the work required to bootstrap a new contract. eosiocpp will create the two smart contract files with the basic skeleton to get you started. These skeleton files are the same .hpp and .cpp files for the hello contract covered in the hello world contract tutorial</p>
<p>$ eosiocpp -n ${contract}<br>The above will create a new empty project in the ./${project} folder with two files:</p>
<p>${contract}.hpp ${contract}.cpp<br>hpp<br>${contract}.hpp is the header file that contains the variables, constants, and functions referenced by the .cpp file.</p>
<p>cpp<br>${contract}.cpp is the source file that contains the implementations of the functions of the contract.</p>
<p>If you generate the .cpp file using the eosiocpp tool, the generated .cpp file would look similar to the following:</p>
<p>#include <eosiolib eosio.hpp=""></eosiolib></p>
<p>using namespace eosio;</p>
<p>class hello : public eosio::contract {<br>  public:<br>      using contract::contract;</p>
<pre><code>  /// @abi action
  void hi( account_name user ) {
     print( &quot;Hello, &quot;, name{user} );
  }
</code></pre><p>};</p>
<p>EOSIO_ABI( hello, (hi) )<br>The generated skeleton file has one function, hi, that prints the name of the user data parameter passed in the command request.</p>
<p>apply action handler and the EOSIO_ABI macro<br>Every smart contract must provide an apply action handler. The apply action handler is a function that listens to all incoming actions and performs the desired behavior. In order to respond to a particular action, code is required to identify and respond to specific actions requests. apply uses the receiver, code, and action input parameters as filters to map to the desired functions that implement particular actions. The apply function can filter on the code parameter using something like the following:</p>
<p>if (code == N(${contract_name}) {<br>   // your handler to respond to particular action<br>}<br>Within a given code, one can respond to a particular action by filtering on the action parameter. This is normally used in conjunction with the code filter.</p>
<p>if (action == N(${action_name}) {<br>    //your handler to respond to a particular action<br>}<br>The EOSIO_ABI macro<br>To simplify the work for contract developers, the EOSIO_ABI macro encapsulates the lower level action mapping details of the apply function, enabling developers to focus on their application implementation.</p>
<p>#define EOSIO_ABI( TYPE, MEMBERS ) \<br>extern “C” { \<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \<br>      auto self = receiver; \<br>      if( code == self ) { \<br>         TYPE thiscontract( self ); \<br>         switch( action ) { \<br>            EOSIO_API( TYPE, MEMBERS ) \<br>         } \<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \<br>      } \<br>   } \<br>} \<br>A developer needs only to specify the code and action names from the contract in the macro, and all of the underlying C code mapping logic is generated by the macro. An example of use of the macro can be seen above, i.e., EOSIO_ABI( hello, (hi) ) where hello and hi are values from the contract.</p>
<p>wast<br>Any program to be deployed to the EOSIO blockchain must be compiled into WASM format. This is the only format the blockchain accepts.</p>
<p>Once you have the .cpp file ready, you can compile it into a text version of WASM (.wast) using the eosiocpp tool.</p>
<p>$ eosiocpp -o ${contract}.wast ${contract}.cpp<br>abi<br>The Application Binary Interface (ABI) is a JSON-based description on how to convert user actions between their JSON and Binary representations. The ABI also describes how to convert the database state to/from JSON. Once you have described your contract via an ABI, developers and users will be able to interact with your contract seamlessly via JSON.</p>
<p>The ABI file can be generated from the .hpp files using the eosiocpp tool:</p>
<p>$ eosiocpp -g ${contract}.abi ${contract}.hpp<br>The following is an example of what the skeleton contract ABI looks like, created using eosiocpp -g as shown above:</p>
<p>{<br>  “____comment”: “This file was generated by eosio-abigen. DO NOT EDIT - 2018-05-07T21:16:48”,<br>  “types”: [],<br>  “structs”: [{<br>      “name”: “hi”,<br>      “base”: “”,<br>      “fields”: [{<br>          “name”: “user”,<br>          “type”: “account_name”<br>        }<br>      ]<br>    }<br>  ],<br>  “actions”: [{<br>      “name”: “hi”,<br>      “type”: “hi”,<br>      “ricardian_contract”: “”<br>    }<br>  ],<br>  “tables”: [],<br>  “ricardian_clauses”: []<br>}<br>You will notice that this ABI defines an action hi of type hi. This tells EOSIO that when ${account}-&gt;hi action is seen that the payload is of type hi. The type hi is defined in the structs array in the object, with name set to hi.</p>
<p>The ABI has one input field, user, with type account_name. account_name is a built-in type used to represent a base32 string as uint64. To see more about built-in types, check here.</p>
<p>Debugging Smart Contracts<br>In order to debug your smart contract, you will need to setup a local nodeos node. This local node can be run as separate private testnet or as an extension of networked testnet.</p>
<p>When creating your smart contract for the first time, it is recommended to test and debug your smart contract on a private testnet first, since you have full control of the entire blockchain. This enables you to have unlimited amount of currency needed, and you can just reset the state of the blockchain whenever you want. When it is ready for production, debugging on a public testnet can be done by connecting your local nodeos to the public testnet. You can then see the log of the testnet in your local nodeos.</p>
<p>The concept is the same, so for the following guide, debugging on the private single node testnet will be covered.</p>
<p>If you haven’t set up your own local nodeos, please follow the setup guide. By default, your local nodeos will run in a private testnet.</p>
<p>Method<br>The main method used to debug smart contract is Caveman Debugging, where we utilize print statements to inspect the value of variables and check the flow of the contract. Printing in smart contracts can be done through the Print API (C and C++). The C++ API is a wrapper for the C API, so most often we will just use the C++ API.</p>
<p>Print API<br>The Print C API supports the following options for print various data types:</p>
<p>prints - a null terminated char array (string)<br>prints_l - any char array (string) with given size<br>printi - 64-bit unsigned integer<br>printi128 - 128-bit unsigned integer<br>printd - double encoded as 64-bit unsigned integer<br>printn - base32 string encoded as 64-bit unsigned integer<br>printhex - hex given binary of data and its size<br>The Print C++ API wraps some of the C API by overriding the print() function, thus encapsulating some of the data type-specific details and reducing concern about which specific print function to use. The Print C++ API supports:</p>
<p>a null terminated char array (string)<br>integer (128-bit unsigned, 64-bit unsigned, 32-bit unsigned, signed, unsigned)<br>base32 string encoded as 64-bit unsigned integer<br>struct that has print() method<br>There is also a compile-time print_f function that can be used for debugging. Instances of the % symbol in the format string will be positionally filled in with the right type. E.g.,</p>
<pre><code>auto count = 5;
auto some_name = &quot;this is the name&quot;;
print_f(&quot;Count = % and some_name = %\n&quot;, count, some_name);
</code></pre><p>Example<br>Here we write a new contract as example for debugging. We’ll start by generating a skeleton for contract debug.</p>
<p>$ eosiocpp -n debug<br>$ cd debug<br>debug.cpp<br>Modify the generated debug.cpp file to look as follows.</p>
<p>#include <eosiolib eosio.hpp=""></eosiolib></p>
<p>class debug : public eosio::contract {<br>  public:<br>      using contract::contract;</p>
<pre><code>  // @abi action
  void debugfunc( account_name from, account_name to, uint64_t amount ) {
     auto header = &quot;======== debugfunc ========&quot;;
     eosio::print( header, &quot;\n&quot; );
     eosio::print( &quot;from = &quot;, from, &quot;  to = &quot;, to, &quot;  amount = &quot;, amount, &quot;\n&quot; );
     eosio::print( &quot;from = &quot;, eosio::name{from}, &quot;  to = &quot;, eosio::name{to}, &quot;  amount = &quot;, amount, &quot;\n&quot; );
  }
</code></pre><p>};</p>
<p>EOSIO_ABI( debug, (debugfunc) )<br>debug.wast<br>Generate the debug.wast file using the following:</p>
<p>$ eosiocpp -o debug.wast debug.cpp<br>debug.abi<br>The debug.abi file can be generated using eosiocpp -g debug.abi debug.cpp:</p>
<p>{<br>  “____comment”: “This file was generated by eosio-abigen. DO NOT EDIT - 2018-05-08T19:11:54”,<br>  “types”: [],<br>  “structs”: [{<br>      “name”: “debugfunc”,<br>      “base”: “”,<br>      “fields”: [{<br>          “name”: “from”,<br>          “type”: “account_name”<br>        },{<br>          “name”: “to”,<br>          “type”: “account_name”<br>        },{<br>          “name”: “amount”,<br>          “type”: “uint64”<br>        }<br>      ]<br>    }<br>  ],<br>  “actions”: [{<br>      “name”: “debugfunc”,<br>      “type”: “debugfunc”,<br>      “ricardian_contract”: “”<br>    }<br>  ],<br>  “tables”: [],<br>  “ricardian_clauses”: []<br>}<br>Deploy and Apply an Action<br>We can now deploy and send an action request to it. This assumes that you have debug account created and have its key in your wallet.</p>
<p>$ cleos set contract debug debug.wast debug.abi<br>$ cleos push action debug debugfunc ‘[“fred”, “barney”, 200 ]’ -p debug<br>When you check your local nodeos node log, you will see the following lines after the above action is applied.</p>
<p>======== debugfunc ========<br>from = 6761187270264356864  to = 4156599770598604800  amount = 200<br>from = fred  to = barney  amount = 200<br>Using this technique, you can confirm that your actions are behaving as desired. You might see messages two or more times. This is normal because each transaction is being applied during verification, block generation, and block application.</p>

  </div>
</div>


<p class="nav-foot">
  <span class="left"><a href="/2018/05/21/online-eos-10/">« Persistenc...</a></span>
  <span class="right"><a href="/2018/05/21/online-eos-12/">Getting St... »</a></span>
</p>

<!-- 文档信息 -->
<div class="post-foot">
  <h3>文档信息</h3>
  <ul>
    <li>版权声明：自由转载-非商用-非衍生-保持署名（
      <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）
    </li>
    <li>作者：<a href="/">Lian</a></li>
    <li>日期：2018年05月21日 20:05</li>
    <li>邮箱：lian1925@126.com</li>
  </ul>
</div>
      




<div class="content-comment">
  <h2>留言</h2>
  
  
		
</div>

<!-- 评论输入组件，填写数据：留言，称呼，电子邮件 -->

<div class="form-comment">
  <h2>
		我要发表看法
	</h2>

	<form method="post" 
	target="targetIfr"
	action="">
	 <!-- 留言正文 -->
	 
		
<p>
	<label for="comment-content">
		您的留言:
	</label>
</p>

<p>
	<textarea 
	id="comment-content" 
	name="content" 
	rows="10" cols="50">
	</textarea>
</p>

		<!-- 姓名 -->
	 
		
<p>
	<label for="comment-author">
		您的大名:
	</label>
</p>

<p>
	<input 
	id="comment-author" 
	name="author" 
	size="30" 
	value=""
	pattern="^.{2,150}$"
	required
	>
	<span class="hint">
			 «-必填
	</span
</p>


		<!-- 微信 -->
	 
		
<p>
	<label for="comment-wechat">
		您的微信:
	</label>
</p>

<p>
	<input 
	id="comment-wechat" 
	name="wechat" 
	size="30" 
	value=""
	pattern="^[a-zA-Zd_]{5,}$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		<!-- 电子邮箱 -->
		
		
<p>
	<label for="comment-email">
		电子邮箱：
	</label>
</p>

<p>
	<input 
	id="comment-email" 
	name="email" 
	size="30" 
	value=""
	pattern="^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		
		<p>

		
<div class="button">
    <input 
    class="submit-button" 
    onclick="doButton('addComment')"
    value="发表">
    <span class="hint"> «- 点击按钮</span>
</div>
		</p>
	</form>
	<iframe name="targetIfr" style="display:none"></iframe> 
</div>


<!-- data:{
	name:'',
	type:'passwor',
	label:'您的大名',
	hint:'',
	pattern:'[A-z]{3}',
	required:"required"
} -->


<p id="info-meta" style="display:none;">
  online-eos-11
</p>


<p id="info-url" style="display:none;">
  
</p>

<div class="footer">
  Copyright @ <a href="/">lian</a> | 2009-2018
</div>

</div>

<script src="/js/jquery.js"></script>
<script src="/js/APlayer.min.js"></script>
<script src="/js/post.js"></script>

</body>

</html>

