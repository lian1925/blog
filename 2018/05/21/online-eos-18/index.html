
<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="icon" type="image/png" href="/img/sand2.png">
  <link rel="shortcut icon" type="image/x-icon" href="/img/sand2.png">
  <meta property="og:image" content="https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png">
  
  <link rel="stylesheet" href="/css/style.css?v=1.3"> 
  <link href="//vjs.zencdn.net/6.7/video-js.min.css" rel="stylesheet">
  <script src="//vjs.zencdn.net/6.7/video.min.js"></script>
  
  <title>Tic Tac Toe | 小沙丘的网络漫游记</title>
 <meta name="description" content="" >

 <!-- 百度统计 -->
 <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?eafa0040e1ab3bed28ce82ef03de6e01";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css"></head>
<body>
  
  <script>
      if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
        document.body.classList.add('mobile');            
      } else{
        document.body.classList.add('pc');
        document.getElementsByTagName("html")[0].style.fontSize="62.5%";
      }
      var u = navigator.userAgent;
var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if(isiOS){
  document.body.classList.add('ios');
  document.getElementsByTagName("html")[0].style.fontSize="65%";
           
}
    </script>

  <div class="container">
<!-- 用于文章页面的顶部，提供返回主页和主题页的按键 -->
<!-- 头部开始 -->

<div id="header">
    <p>小沙丘的网络漫游记
      <span> » 
        <a href="/home/">首页</a>
      </span>
      
      <span> » 
          <a href="/tags/EOS/">
            EOS
          </a>
      </span>
      
    </p>
</div>

<!-- 头部结束 -->



<!-- 分类组件，放置于文章页面的顶部，提供上(或下)一篇导航按键。 -->
<div class="asset-nav">
    <div class="entry-categories">
      <p>主题：
        <span> 
            <a href="/tags/EOS/">
              EOS
            </a>
        </span>
      </p>
    </div>
    <div class="entry-location-mobile">
        <span>
            
            <a href="/2018/05/21/online-eos-17/">
            &#8676;
            </a>
        </span>
        <span>
            
            <a href="/2018/05/21/online-eos-19/">
              &#8677;
            </a>
        </span>
    </div>
    <div class="entry-location">
        <P>上一篇：
                <a href="/2018/05/21/online-eos-17/">
                    Bios Boot Sequence
                </a>
        </P>
        <P>下一篇：

                <a href="/2018/05/21/online-eos-19/">
                    Single Host Multinode
                </a>
        </P>
    </div>
</div>

<div class="post">
<div class="title-post">
<h1>Tic Tac Toe</h1>
<div class="post-meta">
  <p>作者： Lian</p>
  <p>日期：
    2018年05月21日 20:05
  </p>
</div>
</div>



  
  <div class="page">
      <p>Objective<br>The following tutorial will guide the user to build a sample Player vs Player game contract. We will use tic tac toe game to demonstrate this. Final result of this tutorial can be found here.</p>
<p>Assumption<br>For this game, we are using a standard 3x3 tic tac toe board. Players are divided into two roles: host and challenger. Host always makes the first move. Each pair of players can ONLY have up to two games at the same time, one where the first player becomes the host and the other one where the second player becomes the host.</p>
<p>Board<br>Instead of using o and x as in the traditional tic tac toe game. We use 1 to denote movement by host, 2 to denote movement by challenger, and 0 to denote empty cell. Furthermore, we will use one dimensional array to store the board. Hence:</p>
<p>(0,0)    (1,0)    (2,0)<br>(0,0)    -    o    x<br>(0,1)    -    x    -<br>(0,2)    x    o    o<br>Assuming x is host, the above board is equal to [0, 2, 1, 0, 1, 0, 1, 2, 2]</p>
<p>Action<br>User will have the following actions to interact with this contract:</p>
<p>create: create a new game<br>restart: restart an existing game, host or challenger is allowed to do this<br>close: close an existing game, which frees up the storage used to store the game, only host is allowed to do this<br>move: make a movement<br>Contract account<br>For the following guide, we are going to push the contract to an account called tic.tac.toe. In case tic.tac.toe account name is already taken, you can also use another account by replacing any occurence of tic.tac.toe in the code with your account name. If you haven’t created the account, please create the account first.</p>
<p>$ cleos create account ${creator_name} ${contract_account_name} ${contract_pub_owner_key} ${contract_pub_active_key} –permission ${creator_name}@active</p>
<h1 id="e-g-cleos-create-account-inita-tic-tac-toe-EOS4toFS3YXEQCkuuw1aqDLrtHim86Gz9u3hBdcBw5KNPZcursVHq-EOS7d9A3uLe6As66jzN8j44TXJUqJSK3bFjjEEqR4oTvNAB3iM9SA-–permission-inita-active"><a href="#e-g-cleos-create-account-inita-tic-tac-toe-EOS4toFS3YXEQCkuuw1aqDLrtHim86Gz9u3hBdcBw5KNPZcursVHq-EOS7d9A3uLe6As66jzN8j44TXJUqJSK3bFjjEEqR4oTvNAB3iM9SA-–permission-inita-active" class="headerlink" title="e.g. $ cleos create account inita tic.tac.toe  EOS4toFS3YXEQCkuuw1aqDLrtHim86Gz9u3hBdcBw5KNPZcursVHq EOS7d9A3uLe6As66jzN8j44TXJUqJSK3bFjjEEqR4oTvNAB3iM9SA –permission inita@active"></a>e.g. $ cleos create account inita tic.tac.toe  EOS4toFS3YXEQCkuuw1aqDLrtHim86Gz9u3hBdcBw5KNPZcursVHq EOS7d9A3uLe6As66jzN8j44TXJUqJSK3bFjjEEqR4oTvNAB3iM9SA –permission inita@active</h1><p>Ensure that you have your wallet unlocked and the creator’s private active key in the wallet imported, otherwise the above command will fail.</p>
<p>Start!<br>We are going to create three files here:</p>
<p>tic_tac_toe.hpp =&gt; header file where the structure of the contract is defined<br>tic_tac_toe.cpp =&gt; main logic of the contract<br>tic_tac_toe.abi =&gt; interface for user to interact with the contract NB: In this example we use the account name of N(tic.tac.toe) for the contract account. If you plan to use a differnt name for the contract account, then replace tic.tac.toe with your account name.<br>Defining Structure<br>Let’s first start with the header file and define the structure of the contract. Open tic_tac_toe.hpp and start with the following boilerplate</p>
<p>// Import necessary library</p>
<p>#include <eosiolib eosio.hpp=""> // Generic eosio library, i.e. print, type, math, etc</eosiolib></p>
<p>using namespace eosio;<br>namespace tic_tac_toe {<br>   static const account_name games_account = N(games);<br>   static const account_name code_account = N(tic.tac.toe);<br>    // Your code here<br>}<br>Games Table<br>For this contract, we will need to have a table that stores a list of games. Let’s define it:</p>
<p>…<br>namespace tic_tac_toe {<br>    …<br>    typedef eosio::multi_index&lt; games_account, game&gt; games;<br>}</p>
<p>First template parameter defines the name of the table<br>Second template parameter defines the structure that it stores (will be defined in the next section)<br>Game Structure<br>Let’s define structure for the game. Ensure that this struct definition appears before the table definition in the code.</p>
<p>…<br>namespace tic_tac_toe {<br>   static const uint32_t board_len = 9;<br>   struct game {<br>      game() {}<br>      game(account_name challenger, account_name host):challenger(challenger), host(host), turn(host) {<br>         // Initialize board<br>         initialize_board();<br>      }<br>      account_name     challenger;<br>      account_name     host;<br>      account_name     turn; // = account name of host/ challenger<br>      account_name     winner = N(none); // = none/ draw/ account name of host/ challenger<br>      uint8_t          board[9]; //</p>
<pre><code>  // Initialize board with empty cell
  void initialize_board() {
     for (uint8_t i = 0; i &lt; board_len ; i++) {
        board[i] = 0;
     }
  }

  // Reset game
  void reset_game() {
     initialize_board();
     turn = host;
     winner = N(none);
  }

  auto primary_key() const { return challenger; }

  EOSLIB_SERIALIZE( game, (challenger)(host)(turn)(winner)(board) )
</code></pre><p>   };<br>}<br>The primary_key method is required by the above table definition for games. That is how the table knows what field is the lookup key for the table.</p>
<p>Action Structure<br>Create<br>To create the game, we need host account name and challenger’s account name. The EOSLIB_SERIALIZE macro provides serialize and deserialize methods so that actions can be passed back and forth between the contracts and the nodeos system.</p>
<p>…<br>namespace tic_tac_toe {<br>   …<br>   struct create {<br>      account_name   challenger;<br>      account_name   host;</p>
<pre><code>  EOSLIB_SERIALIZE( create, (challenger)(host) )
</code></pre><p>   };<br>   …<br>}<br>Restart<br>To restart the game, we need host account name and challenger’s account name to identify the game. Furthermore, we need to specify who wants to restart the game, so we can verify the correct signature is provided.</p>
<p>…<br>namespace tic_tac_toe {<br>   …<br>   struct restart {<br>      account_name   challenger;<br>      account_name   host;<br>      account_name   by;</p>
<pre><code>  EOSLIB_SERIALIZE( restart, (challenger)(host)(by) )
</code></pre><p>   };<br>   …<br>}<br>Close<br>To close the game, we need host account name and challenger’s account name to identify the game.</p>
<p>…<br>namespace tic_tac_toe {<br>   …<br>   struct close {<br>      account_name   challenger;<br>      account_name   host;</p>
<pre><code>  EOSLIB_SERIALIZE( close, (challenger)(host) )
</code></pre><p>   };<br>   …<br>}<br>Move<br>To make a move, we need host account name and challenger’s account name to identify the game. Furthermore, we need to specify who makes this move and the movement he is making.</p>
<p>…<br>namespace tic_tac_toe {<br>   …<br>   struct movement {<br>      uint32_t    row;<br>      uint32_t    column;</p>
<pre><code>  EOSLIB_SERIALIZE( movement, (row)(column) )
</code></pre><p>   };</p>
<p>   struct move {<br>      account_name   challenger;<br>      account_name   host;<br>      account_name   by; // the account who wants to make the move<br>      movement       mvt;</p>
<pre><code>  EOSLIB_SERIALIZE( move, (challenger)(host)(by)(mvt) )
</code></pre><p>   };<br>   …<br>}<br>You can see the final tic_tac_toe.hpp here</p>
<p>Main<br>Let’s open tic_tac_toe.cpp and setup the boilerplate</p>
<p>#include “tic_tac_toe.hpp”<br>using namespace eosio;<br>/**</p>
<ul>
<li>The apply() method must have C calling convention so that the blockchain can lookup and</li>
<li><p>call these methods.<br>*/<br>extern “C” {</p>
<p>using namespace tic_tac_toe;<br>/// The apply method implements the dispatch of events to this contract<br>void apply( uint64_t receiver, uint64_t code, uint64_t action ) {<br>   // Put your action handler here<br>}</p>
</li>
</ul>
<p>} // extern “C”<br>Action handler<br>We want tic_tac_toe contract to only react to actions sent to the tic.tac.toe account and react differently according to the type of the action. Let’s add an impl struct with overloaded ‘on’ methods taking the different action types (this may seem like overkill for this example, but you will see this pattern employed in other contracts that you can extend, like currency):</p>
<p>using namespace eosio;<br>namespace tic_tac_toe {<br>struct impl {<br>   …<br>   /// The apply method implements the dispatch of events to this contract<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {</p>
<pre><code>  if (code == code_account) {
     if (action == N(create)) {
        impl::on(eosio::unpack_action_data&lt;tic_tac_toe::create&gt;());
     } else if (action == N(restart)) {
        impl::on(eosio::unpack_action_data&lt;tic_tac_toe::restart&gt;());
     } else if (action == N(close)) {
        impl::on(eosio::unpack_action_data&lt;tic_tac_toe::close&gt;());
     } else if (action == N(move)) {
        impl::on(eosio::unpack_action_data&lt;tic_tac_toe::move&gt;());
     }
  }
</code></pre><p>   }</p>
<p>};<br>}</p>
<p>…<br>extern “C” {</p>
<p>   using namespace tic_tac_toe;<br>   /// The apply method implements the dispatch of events to this contract<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {<br>      impl().apply(receiver, code, action);<br>   }</p>
<p>} // extern “C”<br>Notice that we use unpack_action_data<t>() before passing it to specific handler, unpack_action_data<t>() is converting the action that the contract receives to struct T.</t></t></p>
<p>To make things tidy, we will encapsulate the action handlers inside struct impl:</p>
<p>…<br>struct impl {<br>…<br>   /**</p>
<pre><code>* @param create - action to be applied
*/
</code></pre><p>   void on(const create&amp; c) {<br>      // Put code for create action here<br>   }</p>
<p>   /**</p>
<pre><code>* @brief Apply restart action
* @param restart - action to be applied
*/
</code></pre><p>   void on(const restart&amp; r) {<br>      // Put code for restart action here<br>   }</p>
<p>   /**</p>
<pre><code>* @brief Apply close action
* @param close - action to be applied
*/
</code></pre><p>   void on(const close&amp; c) {<br>      // Put code for close action here<br>   }</p>
<p>   /**</p>
<pre><code>* @brief Apply move action
* @param move - action to be applied
*/
</code></pre><p>   void on(const move&amp; m) {<br>      // Put code for move action here<br>   }</p>
<p>   /// The apply method implements the dispatch of events to this contract<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) {<br>…<br>Create Action Handler<br>For the create action handler, we want to:</p>
<p>Ensure that the action has signature from the host<br>Ensure that the challenger and host are not the same player<br>Ensure that there is no existing game<br>Store the newly created game into the db<br>struct impl {<br>   …<br>   /**</p>
<pre><code>* @brief Apply create action
* @param create - action to be applied
*/
</code></pre><p>   void on(const create&amp; c) {<br>      require_auth(c.host);<br>      eosio_assert(c.challenger != c.host, “challenger shouldn’t be the same as host”);</p>
<pre><code>  // Check if game already exists
  games existing_host_games(code_account, c.host);
  auto itr = existing_host_games.find( c.challenger );
  eosio_assert(itr == existing_host_games.end(), &quot;game already exists&quot;);

  existing_host_games.emplace(c.host, [&amp;]( auto&amp; g ) {
     g.challenger = c.challenger;
     g.host = c.host;
     g.turn = c.host;
  });
</code></pre><p>   }<br>   …<br>}<br>Restart Action Handler<br>For the restart action handler, we want to:</p>
<p>Ensure that the action has signature from the host/ challenger<br>Ensure that the game exists<br>Ensure that the restart action is done by host/ challenger<br>Reset the game<br>Store the updated game to the db<br>struct impl {<br>   …<br>   /**</p>
<pre><code>* @brief Apply restart action
* @param restart - action to be applied
*/
</code></pre><p>   void on(const restart&amp; r) {<br>      require_auth(r.by);</p>
<pre><code>  // Check if game exists
  games existing_host_games(code_account, r.host);
  auto itr = existing_host_games.find( r.challenger );
  eosio_assert(itr != existing_host_games.end(), &quot;game doesn&#39;t exists&quot;);

  // Check if this game belongs to the action sender
  eosio_assert(r.by == itr-&gt;host || r.by == itr-&gt;challenger, &quot;this is not your game!&quot;);

  // Reset game
  existing_host_games.modify(itr, itr-&gt;host, []( auto&amp; g ) {
     g.reset_game();
  });
</code></pre><p>   }<br>   …<br>}<br>Close Action Handler<br>For the close action handler, we want to:</p>
<p>Ensure that the action has signature from the host<br>Ensure that the game exists<br>Remove the game from the db<br>struct impl {<br>   …<br>   /**</p>
<pre><code>* @brief Apply close action
* @param close - action to be applied
*/
</code></pre><p>   void on(const close&amp; c) {<br>      require_auth(c.host);</p>
<pre><code>  // Check if game exists
  games existing_host_games(code_account, c.host);
  auto itr = existing_host_games.find( c.challenger );
  eosio_assert(itr != existing_host_games.end(), &quot;game doesn&#39;t exists&quot;);

  // Remove game
  existing_host_games.erase(itr);
</code></pre><p>   }<br>   …<br>}<br>Move Action Handler<br>For the move action handler, we want to:</p>
<p>Ensure that the action has signature from the host/ challenger<br>Ensure that the game exists<br>Ensure that the game is not finished yet<br>Ensure that the move action is done by host/ challenger<br>Ensure that this is the right user’s turn<br>Verify movement is valid<br>Update board with the new move<br>Change the move_turn to the other player<br>Determine if there is a winner<br>Store the updated game to the db<br>struct impl {<br>   …<br>   bool is_valid_movement(const movement&amp; mvt, const game&amp; game_for_movement) {<br>      // Put code here<br>   }</p>
<p>   account_name get_winner(const game&amp; current_game) {<br>      // Put code here<br>   }<br>   …<br>   /**</p>
<pre><code>* @brief Apply move action
* @param move - action to be applied
*/
</code></pre><p>   void on(const move&amp; m) {<br>      require_auth(m.by);</p>
<pre><code>  // Check if game exists
  games existing_host_games(code_account, m.host);
  auto itr = existing_host_games.find( m.challenger );
  eosio_assert(itr != existing_host_games.end(), &quot;game doesn&#39;t exists&quot;);

  // Check if this game hasn&#39;t ended yet
  eosio_assert(itr-&gt;winner == N(none), &quot;the game has ended!&quot;);
  // Check if this game belongs to the action sender
  eosio_assert(m.by == itr-&gt;host || m.by == itr-&gt;challenger, &quot;this is not your game!&quot;);
  // Check if this is the  action sender&#39;s turn
  eosio_assert(m.by == itr-&gt;turn, &quot;it&#39;s not your turn yet!&quot;);


  // Check if user makes a valid movement
  eosio_assert(is_valid_movement(m.mvt, *itr), &quot;not a valid movement!&quot;);

  // Fill the cell, 1 for host, 2 for challenger
  const auto cell_value = itr-&gt;turn == itr-&gt;host ? 1 : 2;
  const auto turn = itr-&gt;turn == itr-&gt;host ? itr-&gt;challenger : itr-&gt;host;
  existing_host_games.modify(itr, itr-&gt;host, [&amp;]( auto&amp; g ) {
     g.board[m.mvt.row * 3 + m.mvt.column] = cell_value;
     g.turn = turn;

     //check to see if we have a winner
     g.winner = get_winner(g);
  });
</code></pre><p>   }<br>   …<br>}<br>Movement Validation<br>Valid movement is defined as movement done inside the board on an empty cell:</p>
<p>struct impl {<br>   …<br>   /**</p>
<pre><code>* @brief Check if cell is empty
* @param cell - value of the cell (should be either 0, 1, or 2)
* @return true if cell is empty
*/
</code></pre><p>   bool is_empty_cell(const uint8_t&amp; cell) {<br>      return cell == 0;<br>   }</p>
<p>   /**</p>
<pre><code>* @brief Check for valid movement
* @detail Movement is considered valid if it is inside the board and done on empty cell
* @param movement - the movement made by the player
* @param game - the game on which the movement is being made
* @return true if movement is valid
*/
</code></pre><p>   bool is_valid_movement(const movement&amp; mvt, const game&amp; game_for_movement) {<br>      uint32_t movement_location = mvt.row * 3 + mvt.column;<br>      bool is_valid = movement_location &lt; board_len &amp;&amp; is_empty_cell(game_for_movement.board[movement_location]);<br>      return is_valid;<br>   }<br>   …<br>}<br>Get Winner<br>Winner is defined as the first player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row.</p>
<p>struct impl {<br>   …<br>   /**</p>
<pre><code>* @brief Get winner of the game
* @detail Winner of the game is the first player who made three consecutive aligned movement
* @param game - the game which we want to determine the winner of
* @return winner of the game (can be either none/ draw/ account name of host/ account name of challenger)
*/
</code></pre><p>   account_name get_winner(const game&amp; current_game) {<br>      if((current_game.board[0] == current_game.board[4] &amp;&amp; current_game.board[4] == current_game.board[8]) ||<br>         (current_game.board[1] == current_game.board[4] &amp;&amp; current_game.board[4] == current_game.board[7]) ||<br>         (current_game.board[2] == current_game.board[4] &amp;&amp; current_game.board[4] == current_game.board[6]) ||<br>         (current_game.board[3] == current_game.board[4] &amp;&amp; current_game.board[4] == current_game.board[5])) {<br>         //  - | - | x    x | - | -    - | - | -    - | x | -<br>         //  - | x | -    - | x | -    x | x | x    - | x | -<br>         //  x | - | -    - | - | x    - | - | -    - | x | -<br>         if (current_game.board[4] == 1) {<br>            return current_game.host;<br>         } else if (current_game.board[4] == 2) {<br>            return current_game.challenger;<br>         }<br>      } else if ((current_game.board[0] == current_game.board[1] &amp;&amp; current_game.board[1] == current_game.board[2]) ||<br>                 (current_game.board[0] == current_game.board[3] &amp;&amp; current_game.board[3] == current_game.board[6])) {<br>         //  x | x | x       x | - | -<br>         //  - | - | -       x | - | -<br>         //  - | - | -       x | - | -<br>         if (current_game.board[0] == 1) {<br>            return current_game.host;<br>         } else if (current_game.board[0] == 2) {<br>            return current_game.challenger;<br>         }<br>      } else if ((current_game.board[2] == current_game.board[5] &amp;&amp; current_game.board[5] == current_game.board[8]) ||<br>                 (current_game.board[6] == current_game.board[7] &amp;&amp; current_game.board[7] == current_game.board[8])) {<br>         //  - | - | -       - | - | x<br>         //  - | - | -       - | - | x<br>         //  x | x | x       - | - | x<br>         if (current_game.board[8] == 1) {<br>            return current_game.host;<br>         } else if (current_game.board[8] == 2) {<br>            return current_game.challenger;<br>         }<br>      } else {<br>         bool is_board_full = true;<br>         for (uint8_t i = 0; i &lt; board_len; i++) {<br>            if (is_empty_cell(current_game.board[i])) {<br>               is_board_full = false;<br>               break;<br>            }<br>         }<br>         if (is_board_full) {<br>            return N(draw);<br>         }<br>      }<br>      return N(none);<br>   }<br>   …<br>}<br>You can see the final tic_tac_toe.cpp here</p>
<p>Creating ABI<br>Abi (a.k.a Application Binary Interface) is needed here, so the contract can understand the action that you send as binary. Let’s open tic_tac_toe.abi and defines the boilerplate here:</p>
<p>{<br>  “types”: [],<br>  “structs”: [{<br>      “name”: “…”,<br>      “base”: “…”,<br>      “fields”: { … }<br>  }, …],<br>  “actions”: [{<br>      “name”: “…”,<br>      “type”: “…”,<br>      “ricardian_contract”: “…”<br>  }, …],<br>  “tables”: [{<br>      “name”: “…”,<br>      “type”: “…”,<br>      “index_type”: “…”,<br>      “key_names” : […],<br>      “key_types” : […]<br>  }, …],<br>  “clauses: […]<br>types: list of types that can be represented by another data structure or built-in-type (think typedef in c/c++)<br>structs: list of data structures used by the action/ table in the contract<br>actions: list of actions available in the contract<br>tables: list of tables available in the contract<br>Table ABI<br>Remember that in tic_tac_toe.hpp, we create an single index i64 table called games. It stores game structure and use challenger as the key, which data type is account_name. Hence, the abi will be:</p>
<p>{<br>  …<br>  “structs”: [{<br>      “name”: “game”,<br>      “base”: “”,<br>      “fields”: [<br>        {“name”:”challenger”, “type”:”account_name”},<br>        {“name”:”host”, “type”:”account_name”},<br>        {“name”:”turn”, “type”:”account_name”},<br>        {“name”:”winner”, “type”:”account_name”},<br>        {“name”:”board”, “type”:”uint8[]”}<br>      ]<br>    },…<br>  ],<br>  “tables”: [{<br>        “name”: “games”,<br>        “type”: “game”,<br>        “index_type”: “i64”,<br>        “key_names” : [“challenger”],<br>        “key_types” : [“account_name”]<br>      }<br>  ],<br>  …<br>}<br>Actions ABI<br>For the actions, we define the actions inside actions and the structure of the actions inside structs.</p>
<p>{<br>  …<br>  “structs”: [{<br>    …<br>    },{<br>      “name”: “create”,<br>      “base”: “”,<br>      “fields”: [<br>        {“name”:”challenger”, “type”:”account_name”},<br>        {“name”:”host”, “type”:”account_name”}<br>      ]<br>    },{<br>      “name”: “restart”,<br>      “base”: “”,<br>      “fields”: [<br>        {“name”:”challenger”, “type”:”account_name”},<br>        {“name”:”host”, “type”:”account_name”},<br>        {“name”:”by”, “type”:”account_name”}<br>      ]<br>    },{<br>      “name”: “close”,<br>      “base”: “”,<br>      “fields”: [<br>        {“name”:”challenger”, “type”:”account_name”},<br>        {“name”:”host”, “type”:”account_name”}<br>      ]<br>    },{<br>      “name”: “movement”,<br>      “base”: “”,<br>      “fields”: [<br>        {“name”:”row”, “type”:”uint32”},<br>        {“name”:”column”, “type”:”uint32”}<br>      ]<br>    },{<br>      “name”: “move”,<br>      “base”: “”,<br>      “fields”: [<br>        {“name”:”challenger”, “type”:”account_name”},<br>        {“name”:”host”, “type”:”account_name”},<br>        {“name”:”by”, “type”:”account_name”},<br>        {“name”:”mvt”, “type”:”movement”}<br>      ]<br>    }<br>  ],<br>  “actions”: [{<br>      “name”: “create”,<br>      “type”: “create”,<br>      “ricardian_contract”: “”<br>    },{<br>      “name”: “restart”,<br>      “type”: “restart”,<br>      “ricardian_contract”: “”<br>    },{<br>      “name”: “close”,<br>      “type”: “close”,<br>      “ricardian_contract”: “”<br>    },{<br>      “name”: “move”,<br>      “type”: “move”,<br>      “ricardian_contract”: “”<br>    }<br>  ],<br>  …<br>}<br>Compile!<br>Now we need to compile tic_tac_toe.cpp to create the tic_tac_toe.wast file that we will use to deploy the contract into nodeos.</p>
<p>$ eosiocpp -o tic_tac_toe.wast tic_tac_toe.cpp<br>Deploy!<br>Now the wast and abi files (tic_tac_toe.wast and tic_tac_toe.abi) are ready. Time to deploy! Create a directory (let’s call it tic_tac_toe) and copy your generated tic_tac_toe.wast tic_tac_toe.abi files.</p>
<p>$ cleos set contract tic.tac.toe tic_tac_toe<br>Ensure that your wallet is unlocked and you have tic.tac.toe key imported. If you are going to upload the contract to another account beside tic.tac.toe, replace tic.tac.toe with your account name and ensure you have the key for that account in your wallet</p>
<p>Play!<br>After the deployment and the transaction is confirmed, the contract is already available in the blockchain. You can play with it now!</p>
<p>Create<br>$ cleos push action tic.tac.toe create ‘{“challenger”:”inita”, “host”:”initb”}’ –permission initb@active<br>Move<br>$ cleos push action tic.tac.toe move ‘{“challenger”:”inita”, “host”:”initb”, “by”:”initb”, “mvt”:{“row”:0, “column”:0} }’ –permission initb@active<br>$ cleos push action tic.tac.toe move ‘{“challenger”:”inita”, “host”:”initb”, “by”:”inita”, “mvt”:{“row”:1, “column”:1} }’ –permission inita@active<br>Restart<br>$ cleos push action tic.tac.toe restart ‘{“challenger”:”inita”, “host”:”initb”, “by”:”initb”}’ –permission initb@active<br>Close<br>$ cleos push action tic.tac.toe close ‘{“challenger”:”inita”, “host”:”initb”}’ –permission initb@active<br>See the game status<br>$ cleos get table tic.tac.toe initb games<br>{<br>  “rows”: [{<br>      “challenger”: “inita”,<br>      “host”: “initb”,<br>      “turn”: “inita”,<br>      “winner”: “none”,<br>      “board”: [<br>        1,<br>        0,<br>        0,<br>        0,<br>        2,<br>        0,<br>        0,<br>        0,<br>        0<br>      ]<br>    }<br>  ],<br>  “more”: false<br>}</p>

  </div>
</div>


<p class="nav-foot">
  <span class="left"><a href="/2018/05/21/online-eos-21/">« DPOS BFT— ...</a></span>
  <span class="right"><a href="#">无... »</a></span>
</p>

<!-- 文档信息 -->
<div class="post-foot">
  <h3>文档信息</h3>
  <ul>
    <li>版权声明：自由转载-非商用-非衍生-保持署名（
      <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）
    </li>
    <li>作者：<a href="/">Lian</a></li>
    <li>日期：2018年05月21日 20:05</li>
    <li>邮箱：lian1925@126.com</li>
  </ul>
</div>
      




<div class="content-comment">
  <h2>留言</h2>
  
  
		
</div>

<!-- 评论输入组件，填写数据：留言，称呼，电子邮件 -->

<div class="form-comment">
  <h2>
		我要发表看法
	</h2>

	<form method="post" 
	target="targetIfr"
	action="">
	 <!-- 留言正文 -->
	 
		
<p>
	<label for="comment-content">
		您的留言:
	</label>
</p>

<p>
	<textarea 
	id="comment-content" 
	name="content" 
	rows="10" cols="50">
	</textarea>
</p>

		<!-- 姓名 -->
	 
		
<p>
	<label for="comment-author">
		您的大名:
	</label>
</p>

<p>
	<input 
	id="comment-author" 
	name="author" 
	size="30" 
	value=""
	pattern="^.{2,150}$"
	required
	>
	<span class="hint">
			 «-必填
	</span
</p>


		<!-- 微信 -->
	 
		
<p>
	<label for="comment-wechat">
		您的微信:
	</label>
</p>

<p>
	<input 
	id="comment-wechat" 
	name="wechat" 
	size="30" 
	value=""
	pattern="^[a-zA-Zd_]{5,}$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		<!-- 电子邮箱 -->
		
		
<p>
	<label for="comment-email">
		电子邮箱：
	</label>
</p>

<p>
	<input 
	id="comment-email" 
	name="email" 
	size="30" 
	value=""
	pattern="^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		
		<p>

		
<div class="button">
    <input 
    class="submit-button" 
    onclick="doButton('addComment')"
    value="发表">
    <span class="hint"> «- 点击按钮</span>
</div>
		</p>
	</form>
	<iframe name="targetIfr" style="display:none"></iframe> 
</div>


<!-- data:{
	name:'',
	type:'passwor',
	label:'您的大名',
	hint:'',
	pattern:'[A-z]{3}',
	required:"required"
} -->


<p id="info-meta" style="display:none;">
  online-eos-18
</p>


<p id="info-url" style="display:none;">
  
</p>

<div class="footer">
  Copyright @ <a href="/">lian</a> | 2009-2018
</div>

</div>

<script src="/js/jquery.js"></script>
<script src="/js/APlayer.min.js"></script>
<script src="/js/post.js"></script>

</body>

</html>

