
<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="icon" type="image/png" href="/img/sand2.png">
  <link rel="shortcut icon" type="image/x-icon" href="/img/sand2.png">
  <meta property="og:image" content="https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png">
  
  <link rel="stylesheet" href="/css/style.css?v=1.3"> 
  <link href="//vjs.zencdn.net/6.7/video-js.min.css" rel="stylesheet">
  <script src="//vjs.zencdn.net/6.7/video.min.js"></script>
  
  <title>隔离验证 17 | 小沙丘的网络漫游记</title>
 
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css"></head>
<body>
  
  <script>
      if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
        document.body.classList.add('mobile');            
      } else{
        document.body.classList.add('pc');
        document.getElementsByTagName("html")[0].style.fontSize="62.5%";
      }
      var u = navigator.userAgent;
var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if(isiOS){
  document.body.classList.add('ios');
  document.getElementsByTagName("html")[0].style.fontSize="65%";
           
}
    </script>

  <div class="container">
<!-- 用于文章页面的顶部，提供返回主页和主题页的按键 -->
<!-- 头部开始 -->

<div id="header">
    <p>小沙丘的网络漫游记
      <span> » 
        <a href="/home/">首页</a>
      </span>
      
      <span> » 
          <a href="/tags/区块链/">
            区块链
          </a>
      </span>
      
    </p>
</div>

<!-- 头部结束 -->



<!-- 分类组件，放置于文章页面的顶部，提供上(或下)一篇导航按键。 -->
<div class="asset-nav">
    <div class="entry-categories">
      <p>主题：
        <span> 
            <a href="/tags/区块链/">
              区块链
            </a>
        </span>
      </p>
    </div>
    <div class="entry-location-mobile">
        <span>
            
            <a href="/2018/05/13/online-qukuai-doc-16/">
            &#8676;
            </a>
        </span>
        <span>
            
            <a href="/2018/05/13/online-qukuai-doc-18/">
              &#8677;
            </a>
        </span>
    </div>
    <div class="entry-location">
        <P>上一篇：
                <a href="/2018/05/13/online-qukuai-doc-16/">
                    闪电网络 16
                </a>
        </P>
        <P>下一篇：

                <a href="/2018/05/13/online-qukuai-doc-18/">
                    散列法 18
                </a>
        </P>
    </div>
</div>

<div class="post">
<div class="title-post">
<h1>隔离验证 17</h1>
<div class="post-meta">
  <p>作者： Lian</p>
  <p>日期：
    2018年05月13日 14:05
  </p>
</div>
</div>



  
  <div class="page">
      <p>隔离验证本身与块大小这一话题其实没什么关系，“隔离验证一定程度上增加了块大小”这一点其实是副产品，并不是其主要目的，不过由于块大小、分叉的话题太过激烈，而隔离验证恰恰是矛盾一方所努力推进的技术实现，因此被当做是与 2MB 相对应的提升块大小的技术实现。比如，我们经常看到有人说“Classic 是直接升级为 2MB ，Core 是采用另一种叫隔离验证的复杂技术来升级到最多也就是 1.8MB”这类的话，其实，压根就不是那么一回事。</p>
<p>这里，我必须反复强调这句话“隔离验证就是隔离验证，它的主要目的跟它的字面意思一样，就是要隔离的做验证，而不是为了增加块大小，最终隔离验证能增加块大小只是它的副产品”，请记住这句话。</p>
<p>好了，在正式进入到隔离验证的讨论之前，我先问大家一个问题：比特币交易的结构是什么样子的？</p>
<p>今天听课的不是业内人士就是比特币爱好者，大家或多或少对于比特币交易还是有一些理解的，不少人可能还看过类似的一些讲述交易结构的文章，码农们没准儿还翻过 bitcoin wiki 和 开发者文档等内容，甚至还知道一些诸如：TxIn、TxOut、OP_CHECKSIG、OP_EQUAL、ScriptSig、ScriptPubKey 等名词，但您真的“懂”比特币交易了吗？</p>
<p>比如说，比特币交易为什么会设计成这个样子？它好在哪里？不好在哪里？</p>
<p>好了，在正式进入到隔离验证的讨论之前，我先问大家一个问题：比特币交易的结构是什么样子的？</p>
<p>今天听课的不是业内人士就是比特币爱好者，大家或多或少对于比特币交易还是有一些理解的，不少人可能还看过类似的一些讲述交易结构的文章，码农们没准儿还翻过 bitcoin wiki 和 开发者文档等内容，甚至还知道一些诸如：TxIn、TxOut、OP_CHECKSIG、OP_EQUAL、ScriptSig、ScriptPubKey 等名词，但您真的“懂”比特币交易了吗？</p>
<p>比如说，比特币交易为什么会设计成这个样子？它好在哪里？不好在哪里？</p>
<p>让我们来看一个具体的比特币交易：</p>
<pre class=" language-bash"><code class="language-bash">bitcoin-cli getrawtransaction c0a0d0f4de3be3b57f516f127a6fa5d5895f09bfacbb001853593320fb0a4164
0100000001473e2a366b081a0e6645199692ccf2f6e25e4556a18265785a88b46d50fd68c2000000006a4730440220296dd1587b8290a04a9253de431b5dbb698030527df5ca75592ab29eea12e85b0220737cafd85b79a7dea1b29c0a5753432d1dacb50f5225221974e38134617ffc85012103dd38b9b13b24498c382045afb08a4256c3c8bf86e15122df741bd2c2a0bd120fffffffff02a0d21e000000000017a914d1640264c522d9a31aaf69207e57d0a224eb7e668770110100000000001976a914dfd6b01e5ec1ecb1568da79931ddd8327dafd9b588ac00000000

tx_id <span class="token operator">=</span> tx_hash <span class="token operator">=</span> c0a0d0f4de3be3b57f516f127a6fa5d5895f09bfacbb001853593320fb0a4164
raw_tx <span class="token operator">=</span> 0100000001473e2a366b081a0e6645199692ccf2f6e25e4556a18265785a88b46d50fd68c2000000006a4730440220296dd1587b8290a04a9253de431b5dbb698030527df5ca75592ab29eea12e85b0220737cafd85b79a7dea1b29c0a5753432d1dacb50f5225221974e38134617ffc85012103dd38b9b13b24498c382045afb08a4256c3c8bf86e15122df741bd2c2a0bd120fffffffff02a0d21e000000000017a914d1640264c522d9a31aaf69207e57d0a224eb7e668770110100000000001976a914dfd6b01e5ec1ecb1568da79931ddd8327dafd9b588ac00000000

tx_hash <span class="token operator">=</span> double_sha256<span class="token punctuation">(</span>raw_tx<span class="token punctuation">)</span>
</code></pre>
<p>这其实就是原始格式（16进制）的比特币交易：rawtx。比特币网络上传播着的就是这种交易，你发送、接收的比特币交易其实也是这个样子的。</p>
<p>有人可能会说了，看不懂。<br>看不懂？没关系，理解今天的内容，并不需要你能看懂交易格式。<br>刚才那笔交易中，签名是这个样子的：</p>
<pre class=" language-bash"><code class="language-bash">30440220296dd1587b8290a04a9253de431b5dbb698030527df5ca75592ab29eea12e85b0220737cafd85b79a7dea1b29c0a5753432d1dacb50f5225221974e38134617ffc8501
</code></pre>
<p>好了，大家现在可以找个文本编辑器（记事本之类的），然后在原始交易 rawtx 中搜索一下签名，问大家一个问题，签名大约出现在交易中的哪个位置？</p>
<p>搜过的人现在应该都能回答了，在中间靠前的位置，也就是说，签名在交易中，基本上在前半部分的内容里（其实就是 TxIn 的位置）。</p>
<p>现在的问题是，签名为什么要在这里，在这里有什么好处？</p>
<p>答案是：中本聪是这么设计的，所以签名在这里。好处嘛，其实也没什么好处，不止是没有好处，缺点却还不少。</p>
<p>1、由于这种设计，比特币的交易结构中就凭空的隐藏了不少“秘籍”，比如说：未签名交易其实就是用了另一个叫 ScriptPubKey 的内容，先占据着签名所需的位置，然后对这个未签名的交易做签名，再把签名的结果替换进去。这其实是很麻烦的一件事，既不容易说清楚，也很难用代码去实现。当一个交易中有多个输入（TxIn）的时候，又要有一套“秘籍”来依次准备未签名交易，依次把签名替换回去；而当一个交易中又涉及到多重签名的交易时，则有需要另一套约定好的规则来准备未签名交易，再进行签名后的数据替换工作；如果一个交易既涉及多个输入，又涉及多重签名呢？那就是秘籍套秘籍，反正是麻烦的要死；有兴趣且有能力的童鞋们不妨去翻翻比特币协议在各种语言中的实现部分，就会发现，无论是 C++、Java、Python 等语言所编写的比特币协议库，通常都需要写非常多的、混乱不堪的代码来做上述的交易数据构造工作，很头疼，写过的都懂。</p>
<p>2、将签名放在交易结构中，由于签名的可塑性，使得交易也就有了可塑性，比如说，很早以前我就给大家讲过的因为椭圆曲线的对称性，s和s’都是能被验证通过的签名，这种情况下，任何接收到你所广播的交易的节点，都有能力用s’来替换掉s，然后重新广播，重新广播的交易其实有着相同的内容（输入 TxIn 和输出 TxOut），但却有着不同的 tx_id （tx_hash），这样就能达到混淆视听的目的，甚至影响到一些比特币企业（如交易所）的服务。交易延展性不会直接导致您丢币，但会影响到个人和企业对于比特币交易状态的判断，进而可能导致可能出现的资产管理风险。之前，bitcoin-core 在 BIP62 中进行过一些试图努力解决交易延展性问题的尝试，但从某种意义上来讲，交易延展性其实是无法彻底根治的，至少私钥拥有者可以重新生成一个签名，交易不变但签名变了，最终的 tx_id 也就变了，这种情形应用于多重签名的场合，甚至可能会影响到其它钥匙的持有人对于交易的判断，导致一些潜在的资产风险，在当前的交易结构下，我们是无法彻底杜绝这种情况的发生的；</p>
<p>3、当我们需要对交易进行签名时，对每个 TxIn 进行签署的 hash 都是不同的（参见上述的“秘籍”），所以对于“冷钱包”这种离线签名的实现方式其实增加了很大的难度，无论是数据结构还是代码的层面；</p>
<p>也就是说，将签名放在交易内容中其实没有任何好处，反而增加的结构的复杂度和交易延展性的风险，这显然是得不偿失的。<br>那么，最合理的交易结构到底应该是什么样子的呢？其实很简单：</p>
<p>TxIns + TxOuts + [签名]</p>
<p>也就是说把签名单独拿出来，放到外面就能解决上述的所有问题了。</p>
<p>这就回到了今天我们要谈论的标题 – “隔离验证”。</p>
<p>隔离验证其实就是把原来的比特币交易中签名的部分单独拿出来放到另一个叫 witness 的结构中，来达到我所说的目的。</p>
<p>看到这里，大家就明白了吧，通常一个看起来很复杂的课题“隔离验证”，其基本原理其实并不复杂，所要达到的目的其实很简单，就是要把签名拿出来，放到另一个地方，也就是所谓的“隔离”，就这么简单。</p>
<p>签名就是要用来进行“验证”的数据，放在另一个地方就是要“隔离”出来，所以给这件事情起名为“隔离验证”也就再合理不过的了。</p>
<p>通过上面的讲述，大家就应该能理解隔离验证的好处了，其好处的确是巨大的：</p>
<p>交易是交易，签名是签名，对于交易来说，只关心 TxIn 和 TxOut 就好了，我们都清楚一个比特币交易其实就是花一笔之前收到的钱，也就是说要用之前收到的 TxOut 作为这一笔交易的 TxIn 然后发给后续的 TxOut，隔离之后的交易结构使得当您决定好花哪一笔钱、要花给谁的时候，交易的内容就已经是确定了的，交易的数据就不会再发生改变了，最终的 tx_id 也就是不变的了。想要验证签名？那就去 witness 里找到对应的签名数据验证一下合法性即可，又简单、有没有交易延展性的问题，用码农的语言来说，那可真是“不要太爽”！</p>
<p>大家都知道，我们比太钱包提供的是易用安全的冷钱包解决方案，对于我们来说，当然希望在离线签名的过程中，冷私钥需要签署的 hash 是精确的而不是变化的，这其实也是隔离验证的好处之一。</p>
<p>刚才，我再巴比特论坛上看到有人问隔离验证是不是对闪电网络有好处？</p>
<p>我的回答是，隔离验证对于所有的基于比特币区块链的扩展应用（甚至包括交易所和钱包等）都有好处，精确的 tx_id 当然会让很多基于 tx_id 所扩展出来的应用都容易的多，也可靠的多。</p>
<p>上述好处其实就是隔离验证的本质。</p>
<p>所谓的隔离验证，其实本质上不是为了解决块大小的问题而产生的改动，它也不是像一些人所说的那样“是 Core 团队中 BlockStream 公司的几名核心开发者的为了阻挠扩容而采取的阴谋”，而是比特币交易本来就应该是那个样子才对。隔离验证的结构改进，跟当年的压缩格式的公钥（关于这部分内容，可参阅我们之前的一次公开课 – 八卦中本聪，中的内容 <a href="http://8btc.com/thread-14057-3-1.html" target="_blank" rel="external">http://8btc.com/thread-14057-3-1.html</a> ）一样，都属于由于最初的结构设计的不合理而需要改进的内容。</p>
<p>也就是说，比特币的交易，本来就应该是“隔离验证”的才对，只是由于最初中本聪设计成了当前的样子，所以一直才保留至今，如果当年就下了狠心给改好了，没准就没有今天的这么多争议了，比特币程序员们也能省下很多脑细胞用来干更多有意义的事情，而不是跟交易的结构做斗争，各类的比特币企业也能少受一些交易延展性的困扰，等等等等。</p>
<p>好了，讨论了这么多，那么，隔离验证到底应不应该做呢？</p>
<p>我的答案是：当然应该做，合理的改进干嘛不做？比如说，“压缩格式的公钥”，这个改进到底应不应该做呢？</p>
<p>隔离验证的改进应该如何做呢？</p>
<p>由于要考虑到向下兼容、要考虑到各类客户端旧版本的兼容情况，所以开发者们希望尽可能用一种“软分叉”的方式来实现，为了做到这一点，当前一共提出了4个相关的 bip （141-144）。</p>
<p>我们都知道，对于任何一个计算机系统来说，新设计一套结构都是容易的，但想要做到向下兼容就要困难很多，想要让新老结构共存且旧版本还能正常运行就更加困难，尤其是当我们考虑到这些新旧结构的数据还要在同一个区块链上传播的情况，就需要进行更多的努力了。关于这些部分，在几个 bip 中进行了比较详细的描述，有兴趣的可进一步阅读相关技术文档：</p>
<p>比如说：<br>bip141 详细讲述了一个叫 “witness” 的新结构，脚本和签名等数据被移动到了这个新结构中，同时介绍了隔离验证如何做到的向下兼容等；<br>bip142 讲述了隔离验证的新的地址格式；<br>bip143 举例描述了隔离验证交易签名的验证方式；<br>bip144 讲述了如何在保持向下兼容的情况下节点间通报支持隔离验证的情况及传播和请求验证数据的方式；</p>
<p>好了，通过讲述这些内容，大家应该大致能明白隔离验证到底是怎么一回事了，隔离验证本身跟块大小并没有什么关系，只是由于验证数据处于兼容的目的被放在了另一块空间中，同时修改了块上限的计算方式使得隔离验证本身能起到一定程度的扩容作用，才让大家把它当成是另一种扩容方案，并且被当做是 2MB 方案的对立面。</p>
<p>最后，总结一下，隔离验证其实是对之前不太合理的比特币交易结构的一次优化，开发者们试图用一种影响尽可能小的、尽可能向下兼容的、“软分叉”的方式来实现，这种改进本身（就像是“压缩格式的公钥”一样）是非常合理的，与块大小之争没什么直接的关系。如果隔离验证的软分叉上线之后，我们可能会在相当长的一段时间里、在比特币网络上都能看到新旧版本的交易同时存在，就像直到今天，仍有人在用 5 开头的私钥（而不是压缩版本的 K 和 L 开头的私钥）一样。</p>
<p>隔离验证能带来的块大小增加只是个副产品，块大小到底应不应该增加、应该如何增加，那其实是另一个话题，这需要各方充分讨论，并尽可能客观公正的听取对方的意见，我本人就不对块大小争论进行任何评论了。而关于到底应该如何管理比特币代码的问题，这属于 governance issue ，这是政治问题，更不在本次公开课的讨论范围中。</p>
<p>隔离验证是一个应该做的改进，由于与块大小的争议混到了一起，使得不少人在看待“隔离验证”的时候带上了很多的感情色彩。个人建议，隔离验证就是隔离验证，如果要做到向下兼容、软分叉且不出任何问题，需要核心开发者们、产业链上下游的相关企业们、比特币钱包的开发者们共同努力，确保此项改进的安全进行。如果非要问我隔离验证方案是否有风险，我反而觉得最大的风险反而是大家逼着说“你这隔离验证的方案啥时候能上？2MB 可是下个月就能分叉”，逼着核心开发者们叫着劲的仓促上马以达到提升块大小的目的，这就有点得不偿失了，隔离验证的升级还是需要做充分的测试，相关企业和软件解决方案也应尽可能充分的测试兼容性，然后再上线才好。</p>

  </div>
</div>


<p class="nav-foot">
  <span class="left"><a href="/2018/05/13/online-qukuai-doc-16/">« 闪电网络 16</a></span>
  <span class="right"><a href="/2018/05/13/online-qukuai-doc-18/">散列法 18 »</a></span>
</p>

<!-- 文档信息 -->
<div class="post-foot">
  <h3>文档信息</h3>
  <ul>
    <li>版权声明：自由转载-非商用-非衍生-保持署名（
      <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）
    </li>
    <li>作者：<a href="/">Lian</a></li>
    <li>日期：2018年05月13日 14:05</li>
    <li>邮箱：lian1925@126.com</li>
  </ul>
</div>
      




<div class="content-comment">
  <h2>留言</h2>
  
  
		
</div>

<!-- 评论输入组件，填写数据：留言，称呼，电子邮件 -->

<div class="form-comment">
  <h2>
		我要发表看法
	</h2>

	<form method="post" 
	target="targetIfr"
	action="">
	 <!-- 留言正文 -->
	 
		
<p>
	<label for="comment-content">
		您的留言:
	</label>
</p>

<p>
	<textarea 
	id="comment-content" 
	name="content" 
	rows="10" cols="50">
	</textarea>
</p>

		<!-- 姓名 -->
	 
		
<p>
	<label for="comment-author">
		您的大名:
	</label>
</p>

<p>
	<input 
	id="comment-author" 
	name="author" 
	size="30" 
	value=""
	pattern="^.{2,150}$"
	required
	>
	<span class="hint">
			 «-必填
	</span
</p>


		<!-- 微信 -->
	 
		
<p>
	<label for="comment-wechat">
		您的微信:
	</label>
</p>

<p>
	<input 
	id="comment-wechat" 
	name="wechat" 
	size="30" 
	value=""
	pattern="^[a-zA-Zd_]{5,}$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		<!-- 电子邮箱 -->
		
		
<p>
	<label for="comment-email">
		电子邮箱：
	</label>
</p>

<p>
	<input 
	id="comment-email" 
	name="email" 
	size="30" 
	value=""
	pattern="^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		
		<p>

		
<div class="button">
    <input 
    class="submit-button" 
    onclick="doButton('addComment')"
    value="发表">
    <span class="hint"> «- 点击按钮</span>
</div>
		</p>
	</form>
	<iframe name="targetIfr" style="display:none"></iframe> 
</div>


<!-- data:{
	name:'',
	type:'passwor',
	label:'您的大名',
	hint:'',
	pattern:'[A-z]{3}',
	required:"required"
} -->


<p id="info-meta" style="display:none;">
  online-qukuai-doc-17
</p>


<p id="info-url" style="display:none;">
  
</p>

<div class="footer">
  Copyright @ <a href="/">lian</a> | 2009-2018
</div>

</div>

<script src="/js/jquery.js"></script>
<script src="/js/APlayer.min.js"></script>
<script src="/js/post.js"></script>

</body>

</html>

