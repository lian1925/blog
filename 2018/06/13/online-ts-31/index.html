
<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="icon" type="image/png" href="/img/sand2.png">
  <link rel="shortcut icon" type="image/x-icon" href="/img/sand2.png">
  <meta property="og:image" content="https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png">
  
  <link rel="stylesheet" href="/css/style.css?v=1.3"> 
  <link href="//vjs.zencdn.net/6.7/video-js.min.css" rel="stylesheet">
  <script src="//vjs.zencdn.net/6.7/video.min.js"></script>
  
  <title>symbol 独一无二 | 小沙丘的网络漫游记</title>
 <meta name="description" content="" >

 <!-- 百度统计 -->
 <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?eafa0040e1ab3bed28ce82ef03de6e01";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css"></head>
<body>
  
  <script>
      if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
        document.body.classList.add('mobile');            
      } else{
        document.body.classList.add('pc');
        document.getElementsByTagName("html")[0].style.fontSize="62.5%";
      }
      var u = navigator.userAgent;
var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if(isiOS){
  document.body.classList.add('ios');
  document.getElementsByTagName("html")[0].style.fontSize="65%";
           
}
    </script>

  <div class="container">
<!-- 用于文章页面的顶部，提供返回主页和主题页的按键 -->
<!-- 头部开始 -->

<div id="header">
    <p>小沙丘的网络漫游记
      <span> » 
        <a href="/home/">首页</a>
      </span>
      
      <span> » 
          <a href="/tags/TypeScript/">
            TypeScript
          </a>
      </span>
      
    </p>
</div>

<!-- 头部结束 -->



<!-- 分类组件，放置于文章页面的顶部，提供上(或下)一篇导航按键。 -->
<div class="asset-nav">
    <div class="entry-categories">
      <p>主题：
        <span> 
            <a href="/tags/TypeScript/">
              TypeScript
            </a>
        </span>
      </p>
    </div>
    <div class="entry-location-mobile">
        <span>
            
            <a href="/2018/06/12/draft-sanzijing-1/">
            &#8676;
            </a>
        </span>
        <span>
            
            <a href="#">
              &#8677;
            </a>
        </span>
    </div>
    <div class="entry-location">
        <P>上一篇：
                <a href="/2018/06/12/draft-sanzijing-1/">
                    三字经 | 国学
                </a>
        </P>
        <P>下一篇：

                <a href="#">
                    无
                </a>
        </P>
    </div>
</div>

<div class="post">
<div class="title-post">
<h1>symbol 独一无二</h1>
<div class="post-meta">
  <p>作者： Lian</p>
  <p>日期：
    2018年06月13日 10:06
  </p>
</div>
</div>



  
  <div class="page">
      <h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><p>1 编辑器字体要大，方便用户观看<br>2 每节内容要少，用户耐心少<br>3 片头，片尾<br>4 提供课件材料</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="1-深入浅出ES6（八）：Symbols"><a href="#1-深入浅出ES6（八）：Symbols" class="headerlink" title="1 深入浅出ES6（八）：Symbols"></a>1 深入浅出ES6（八）：Symbols</h3><p>那么，Symbols到底是什么呢？</p>
<p>它是JavaScript的第七种原始类型<br>1997年JavaScript首次被标准化，那时只有六种原始类型，在ES6以前，JS程序中使用的每一个值都是以下几种类型之一：</p>
<p>Undefined 未定义<br>Null 空值<br>Boolean 布尔类型<br>Number 数字类型<br>String 字符串类型<br>Object 对象类型<br>每种类型都是多个值的集合，前五个集合是有限的。布尔类型只有两个值，true和false，不会再创造第三种布尔值；数字类型和字符串类型的值更多，标准指明一共有18,437,736,874,454,810,627种不同的数字（包括NaN， 亦即“Not a Number”的缩写，代表非数字），可能存在的字符串类型的值拥有无以匹敌的数量，我估算了一下大约是 (2144,115,188,075,855,872 − 1) ÷ 65,535种……当然，我很可能得出了一个错误的答案，但字符串类型值的集合一定是有限的。</p>
<p>然而，对象类型值的集合是无限的。每一个对象都像珍贵的雪花一样独一无二，每一次你打开一个Web页面，都会创建一堆对象。</p>
<p>ES6新特性中的symbol也是值，但它不是字符串，也不是对象，而是是全新的——第七种类型的原始值。</p>
<p>让我们一起探讨一下symbol的实际应用场景。</p>
<p>从一个简单的布尔类型出发<br>有时候你可以非常轻松地将别人的外部数据存储到一个JavaScript对象中。</p>
<p>举 个例子，假设你正在写一个JS库，可以通过CSS transitions使DOM元素在屏幕上移动。你可能会注意到，当你尝试在一个div元素上同时应用多重CSS transitions时并不会生效。实际效果是丑陋而又不连续的“跳闪”。你认为可以修复这个问题，但前提是你需要一种发现给定元素是否已经移动过的方 法。</p>
<p>应当如何解决这个问题呢？</p>
<p>一种方法是，用CSS API来告诉浏览器元素是否正在移动，但这样简直小题大做。在元素移动的第一时间内你的库就应该记录下移动的状态，所以它自然知道元素正在移动。</p>
<p>你真正想要的是一种持续跟踪某个元素正在移动的方法。你可以维护一个数组，记录所有正在移动的元素，每当你的库被调用来移动某个元素时，你可以检索数组来查看元素是否已经存在，亦即它是否正在移动中。</p>
<p>当然，如果数组非常大的话，线性搜索将会非常缓慢。</p>
<p>实际上你只想为元素设置一个标记：</p>
<pre><code>if (element.isMoving) {
  smoothAnimations(element);
}
element.isMoving = true;
</code></pre><p>这样也会有一些潜在的问题，事实上，你的代码很可能不是唯一一段操作DOM的代码。</p>
<p>你创建的属性很可能影响到其它使用了for-in或Object.keys()的代码。<br>一些聪明的库作者可能已经考虑并使用了这项技术，这样一来你的库就会与已有的库产生某些冲突<br>当然，很可能你比他们更聪明，你先采用了这项技术，但是他们的库仍然无法与你的库默契配合。<br>标准委员会可能决定为所有的元素增加一个.isMoving()方法，到那时你需要重写相关逻辑，必定会有深深的挫败感。<br>当然你可以选择一个乏味而愚蠢的命名（其他人根本不会想用的那些名称）来解决最后的三个问题：</p>
<pre><code>if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {
  smoothAnimations(element);
}
element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;
</code></pre><p>这只会造成无畏的眼疲劳。</p>
<p>借助于密码学，你可以生成一个唯一的属性名称：</p>
<pre><code>// 获取1024个Unicode字符的无意义命名
var isMoving = SecureRandom.generateName();
...
if (element[isMoving]) {
  smoothAnimations(element);
}
element[isMoving] = true;
</code></pre><p>object[name]语法允许你使用几乎任何字符串作为属性名称。所以这个方法行之有效：冲突几乎是不可能的，并且你的代码看起来也很简洁。</p>
<p>但是这也将带来不良的调试体验。每当你在控制台输出（console.log()）包含那个属性的元素时，你将会看到一堆巨大的字符串垃圾。假使你需要比这多得多的类似属性呢？你如何保持它们整齐划一？每当你重载的时候它们的命名甚至都不一样！</p>
<p>为什么这个问题如此困难？我们只想要一个小小的布尔值啊！</p>
<p>symbol是最终的解决方案<br>symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。</p>
<pre><code>var mySymbol = Symbol();
</code></pre><p>调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。</p>
<p>字符串或数字可以作为属性的键，symbol也可以，它不等同于任何字符串，因而这个以symbol为键的属性可以保证不与任何其它属性产生冲突。</p>
<pre><code>obj[mySymbol] = &quot;ok!&quot;;  // 保证不会冲突
console.log(obj[mySymbol]);  // ok!
</code></pre><p>想要在上述讨论的场景中使用symbol，你可以这样做：</p>
<pre><code>// 创建一个独一无二的symbol
var isMoving = Symbol(&quot;isMoving&quot;);
...
if (element[isMoving]) {
  smoothAnimations(element);
}
element[isMoving] = true;
</code></pre><p>有关这段代码的一些解释：</p>
<p>Symbol(“isMoving”)中的isMoving被称作描述。你可以通过console.log()将它打印出来，对调试非常有帮助；你也可以用.toString()方法将它转换为字符串呈现；它也可以被用在错误信息中。</p>
<p>element[isMoving]被称作一个以symbol为键（symbol-keyed）的属性。简而言之，它的名字是symbol而不是一个字符串。除此之外，它与一个普通的属性没有什么区别。</p>
<p>以symbol为键的属性属性与数组元素类似，不能被类似obj.name的点号法访问，你必须使用方括号访问这些属性。</p>
<p>如果你已经得到了symbol，那么访问一个以symbol为键的属性同样简单，以上的示例很好地展示了如何获取element[isMoving]的值以及如何为它赋值。如果我们需要，可以查看属性是否存在：if (isMoving in element)，也可以删除属性：delete element[isMoving]。</p>
<p>另一方面，只有当isMoving在当前作用域中时才会生效。这是symbol的弱封装机制：模块创建了几个symbol，可以在任意对象上使用，无须担心与其它代码创建的属性产生冲突。</p>
<p>symbol键的设计初衷是避免初衷，因此JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的API Object.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键。（我们将在随后的文章中讲解Reflect(反射) API）。</p>
<p>慢慢地我们会发现，越来越多的库和框架将大量使用symbol，语言本身也会将symbol应用于广泛的用途。</p>
<p>但是，到底什么是symbol呢？</p>
<pre><code>&gt; typeof Symbol()
&quot;symbol&quot;
</code></pre><p>确切地说，symbol与其它类型并不完全相像。</p>
<p>symbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。</p>
<p>另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。</p>
<p>ES6中的symbol与Lisp和Ruby这些语言中更传统的symbol类似，但不像它们集成得那么紧密。在Lisp中，所有的标识符都是symbol；在JS中，标识符和大多数的属性键仍然是字符串，symbol只是一个额外的选项。</p>
<p>关于symbol的忠告：symbol不能被自动转换为字符串，这和语言中的其它类型不同。尝试拼接symbol与字符串将得到TypeError错误。</p>
<pre><code>&gt; var sym = Symbol(&quot;&lt;3&quot;);
&gt; &quot;your symbol is &quot; + sym
// TypeError: can&#39;t convert symbol to string
&gt; `your symbol is ${sym}`
// TypeError: can&#39;t convert symbol to string
</code></pre><p>通过String(sym)或sym.toString()可以显示地将symbol转换为一个字符串，从而回避这个问题。</p>
<p>获取symbol的三种方法<br>有三种获取symbol的方法。</p>
<p>调用Symbol()。正如我们上文中所讨论的，这种方式每次调用都会返回一个新的唯一symbol。</p>
<p>调用Symbol.for(string)。这种方式会访问symbol注册表，其中存储了已经存在的一系列symbol。这种方式与通过Symbol()定义的独立symbol不同，symbol注册表中的symbol是共享的。如果你连续三十次调用Symbol.for(“cat”)，每次都会返回相同的symbol。注册表非常有用，在多个web页面或同一个web页面的多个模块中经常需要共享一个symbol。</p>
<p>使用标准定义的symbol，例如：Symbol.iterator。标准根据一些特殊用途定义了少许的几个symbol。</p>
<p>如果你尚不确定symbol是否实用，最后这一章将向你展示symbol在实际应用中发挥的巨大作用，非常有趣！</p>
<p>symbol在ES6规范中的应用<br>在之前的文章《深入浅出ES6（二）：迭代器和for-of循环》中，我们已经领略了借助ES6 symbol的力量避免代码冲突的方法，循环for (var item of myArray)首先调用myArray<a href="">Symbol.iterator</a>，当时我提到这种写法是为了替代myArray.iterator()，拥有更好的向后兼容性。</p>
<p>现在我们知道symbol到底是什么了，自然很容易理解为什么我们要创造一个symbol以及它为我们带来什么新特性。</p>
<p>ES6中还有其它几处使用了symbol的地方。（这些特性在Firefox里尚未实现。）</p>
<p>使instanceof可扩展。在ES6中，表达式object instanceof constructor被指定为构造函数的一个方法：constructor<a href="object">Symbol.hasInstance</a>。这意味着它是可扩展的。</p>
<p>消除新特性和旧代码之间的冲突。这一点非常复杂，但是我们发现，添加某些ES6数组方法会破坏现有的Web网站。其它Web标准有相同的问题：向浏览器中添加新方法会破坏原有的网站。然而，破坏问题主要由动态作用域引起，所以ES6引入一个特殊的symbol——Symbol.unscopables，Web标准可以用这个symbol来阻止某些方法别加入到动态作用域中。</p>
<p>支持新的字符串匹配类型。在ES5中，str.match(myObject)会尝试将myObject转换为正则表达式对象（RegExp）。在ES6中，它会首先检查myObject是否有一个myObject<a href="str">Symbol.match</a>方法。现在的库可以提供自定义的字符串解析类，所有支持RegExp对象的环境都可以正常运行。</p>
<p>这些用例的应用范围都非常小，很难看到这些特性通过它们自身影响我们每日的代码，长期来看才能体现它们的价值。实际上，symbol是PHP和Python中的__doubleUnderscores在JavaScript语言环境中的改进版。标准将借助symbol的力量在未来向语言中添加新的钩子，同时无风险地将新特性添加到你已有的代码中。</p>
<p>我何时可以使用ES6 symbol？<br>symbol在Firefox 36和Chrome 38中均已被实现。Firefox中的实现由我亲自完成，所以如果你的symbol像铙钹（cymbals）一样行为异常，请直接联系我！</p>
<p>为了支持那些尚未支持原生ES6 symbol的浏览器，你可以使用一个polyfill，例如core.js。因为symbol与其它类型不尽相同，所以polyfill目前不是很完美。请阅读注意事项。</p>
<p>下一篇文章，我们将奉上一篇Gastón Silva的文章，讲解如何使用Babel和Broccoli来接触更多的ES6新特性，借鉴这篇文章的经验你可以轻松地开始ES6之旅。</p>
<p>接 下来，我们将深入浅出Collections，这个特性被期待已久，最终在ES6版本加入到JavaScript中。我们将回溯到编程的起源，探索两个古 老的特性，紧接着讨论两个非常相似的特性，它们的生命周期短，但是威力巨大。所以请记得回来，一起探索接下来的旅程！到时见！</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>Symbols<br>介绍<br>自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。</p>
<p>symbol类型的值是通过Symbol构造函数创建的。</p>
<p>let sym1 = Symbol();</p>
<p>let sym2 = Symbol(“key”); // 可选的字符串key<br>Symbols是不可改变且唯一的。</p>
<p>let sym2 = Symbol(“key”);<br>let sym3 = Symbol(“key”);</p>
<p>sym2 === sym3; // false, symbols是唯一的<br>像字符串一样，symbols也可以被用做对象属性的键。</p>
<p>let sym = Symbol();</p>
<p>let obj = {</p>
<pre><code>[sym]: &quot;value&quot;
</code></pre><p>};</p>
<p>console.log(obj[sym]); // “value”<br>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。</p>
<p>const getClassNameSymbol = Symbol();</p>
<p>class C {<br>    <a href="">getClassNameSymbol</a>{<br>       return “C”;<br>    }<br>}</p>
<p>let c = new C();<br>let className = c<a href="">getClassNameSymbol</a>; // “C”<br>众所周知的Symbols<br>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p>
<p>以下为这些symbols的列表：</p>
<p>Symbol.hasInstance<br>方法，会被instanceof运算符调用。构造器对象用来识别一个对象是否是其实例。</p>
<p>Symbol.isConcatSpreadable<br>布尔值，表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开。</p>
<p>Symbol.iterator<br>方法，被for-of语句调用。返回对象的默认迭代器。</p>
<p>Symbol.match<br>方法，被String.prototype.match调用。正则表达式用来匹配字符串。</p>
<p>Symbol.replace<br>方法，被String.prototype.replace调用。正则表达式用来替换字符串中匹配的子串。</p>
<p>Symbol.search<br>方法，被String.prototype.search调用。正则表达式返回被匹配部分在字符串中的索引。</p>
<p>Symbol.species<br>函数值，为一个构造函数。用来创建派生对象。</p>
<p>Symbol.split<br>方法，被String.prototype.split调用。正则表达式来用分割字符串。</p>
<p>Symbol.toPrimitive<br>方法，被ToPrimitive抽象操作调用。把对象转换为相应的原始值。</p>
<p>Symbol.toStringTag<br>方法，被内置方法Object.prototype.toString调用。返回创建对象时默认的字符串描述。</p>
<p>Symbol.unscopables<br>对象，它自己拥有的属性会被with作用域排除在外。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>ES 6 引入了一个新的数据类型 Symbol，它是用来做什么的呢？<br>为了说明 Symbol 的作用，我们先来描述一个使用场景。</p>
<p>我们在做一个游戏程序，用户需要选择角色的种族。</p>
<p>var race = {<br>  protoss: ‘protoss’, // 神族<br>  terran: ‘terran’, // 人族<br>  zerg: ‘zerg’ // 虫族<br>}</p>
<p>function createRole(type){<br>  if(type === race.protoss){创建神族角色}<br>  else if(type === race.terran){创建人族角色}<br>  else if(type === race.zerg){创建虫族角色}<br>}<br>那么用户选择种族后，就需要调用 createRole 来创建角色：</p>
<p>// 传入字符串<br>createRole(‘zerg’)<br>// 或者传入变量<br>createRole(race.zerg)<br>一般传入字符串被认为是不好的做法，所以使用 createRole(race.zerg) 的更多。</p>
<p>如果使用 createRole(race.zerg)，那么聪明的读者会发现一个问题：race.protoss、race.terran、race.zerg 的值为多少并不重要。</p>
<p>改为如下写法，对 createRole(race.zerg) 毫无影响：</p>
<p>var race = {<br>  protoss: ‘askdjaslkfjas;lfkjas;flkj’, // 神族<br>  terran: ‘;lkfalksjfl;askjfsfal;skfj’, // 人族<br>  zerg: ‘qwieqwoirqwoiruoiwqoisrqwroiu’ // 虫族<br>}<br>也就是说：</p>
<p>race.zerg 的值是多少无所谓，只要它的值跟 race.protoss 和 race.terran 的值不一样就行。</p>
<p>Symbol 的用途就是如此：Symbol 可以创建一个独一无二的值（但并不是字符串）。</p>
<p>用 Symbol 来改写上面的 race：</p>
<p>var race = {<br>  protoss: Symbol(),<br>  terran: Symbol(),<br>  zerg: Symbol()<br>}</p>
<p>race.protoss !== race.terran // true<br>race.protoss !== race.zerg // true<br>你也可以给每个 Symbol 起一个名字：</p>
<p>var race = {<br>  protoss: Symbol(‘protoss’),<br>  terran: Symbol(‘terran’),<br>  zerg: Symbol(‘zerg’)<br>}<br>不过这个名字跟 Symbol 的值并没有关系，你可以认为这个名字就是个注释。如下代码可以证明 Symbol 的名字与值无关：</p>
<p>var a1 = Symbol(‘a’)<br>var a2 = Symbol(‘a’)<br>a1 !== a2 // true<br>如果你觉得我说得还是太复杂了，看不懂，你可以记一句话：</p>
<p>Symbol 生成一个全局唯一的值。</p>
<p>以上，就是 Symbol 的简述，更详细更权威的知识参考下面的自学链接。</p>
<p>自学链接：</p>
<p>MDN： Symbol - JavaScript</p>
<p>阮一峰：ECMAScript 6入门</p>

  </div>
</div>


<p class="nav-foot">
  <span class="left"><a href="/2018/05/25/online-ts-23/">« Type Check...</a></span>
  <span class="right"><a href="#">无... »</a></span>
</p>

<!-- 文档信息 -->
<div class="post-foot">
  <h3>文档信息</h3>
  <ul>
    <li>版权声明：自由转载-非商用-非衍生-保持署名（
      <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）
    </li>
    <li>作者：<a href="/">Lian</a></li>
    <li>日期：2018年06月13日 10:06</li>
    <li>邮箱：lian1925@126.com</li>
  </ul>
</div>
      




<div class="content-comment">
  <h2>留言</h2>
  
  
		
</div>

<!-- 评论输入组件，填写数据：留言，称呼，电子邮件 -->

<div class="form-comment">
  <h2>
		我要发表看法
	</h2>

	<form method="post" 
	target="targetIfr"
	action="">
	 <!-- 留言正文 -->
	 
		
<p>
	<label for="comment-content">
		您的留言:
	</label>
</p>

<p>
	<textarea 
	id="comment-content" 
	name="content" 
	rows="10" cols="50">
	</textarea>
</p>

		<!-- 姓名 -->
	 
		
<p>
	<label for="comment-author">
		您的大名:
	</label>
</p>

<p>
	<input 
	id="comment-author" 
	name="author" 
	size="30" 
	value=""
	pattern="^.{2,150}$"
	required
	>
	<span class="hint">
			 «-必填
	</span
</p>


		<!-- 微信 -->
	 
		
<p>
	<label for="comment-wechat">
		您的微信:
	</label>
</p>

<p>
	<input 
	id="comment-wechat" 
	name="wechat" 
	size="30" 
	value=""
	pattern="^[a-zA-Zd_]{5,}$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		<!-- 电子邮箱 -->
		
		
<p>
	<label for="comment-email">
		电子邮箱：
	</label>
</p>

<p>
	<input 
	id="comment-email" 
	name="email" 
	size="30" 
	value=""
	pattern="^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		
		<p>

		
<div class="button">
    <input 
    class="submit-button" 
    onclick="doButton('addComment')"
    value="发表">
    <span class="hint"> «- 点击按钮</span>
</div>
		</p>
	</form>
	<iframe name="targetIfr" style="display:none"></iframe> 
</div>


<!-- data:{
	name:'',
	type:'passwor',
	label:'您的大名',
	hint:'',
	pattern:'[A-z]{3}',
	required:"required"
} -->


<p id="info-meta" style="display:none;">
  online-ts-31
</p>


<p id="info-url" style="display:none;">
  
</p>

<div class="footer">
  Copyright @ <a href="/">lian</a> | 2009-2018
</div>

</div>

<script src="/js/jquery.js"></script>
<script src="/js/APlayer.min.js"></script>
<script src="/js/post.js"></script>

</body>

</html>

